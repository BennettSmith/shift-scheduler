#!/usr/bin/env python3
"""
Swift Code Coverage Analysis Tool

This script analyzes code coverage data generated by Swift Package Manager tests
and produces a detailed report. It can be used with any Swift package.

Usage:
    python3 analyze_swift_coverage.py <package_path> [options]
    
    package_path: Path to the Swift package directory (required)
    
Options:
    --filter <pattern>    Only analyze files matching this pattern (e.g., "UseCases")
    --output <path>       Output file path (default: COVERAGE_REPORT.md in package dir)
    --help               Show this help message

Examples:
    # Analyze all files in a package
    python3 analyze_swift_coverage.py ios/Packages/Troop900Application
    
    # Analyze only UseCase files
    python3 analyze_swift_coverage.py ios/Packages/Troop900Application --filter "UseCases"
    
    # Specify output location
    python3 analyze_swift_coverage.py ios/Packages/Troop900Domain --output reports/domain_coverage.md
"""

import json
import sys
import argparse
from pathlib import Path
from collections import defaultdict
from typing import Dict, List, Tuple, Optional

def load_coverage_data(coverage_path: str) -> dict:
    """Load the JSON coverage data file."""
    try:
        with open(coverage_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: Coverage data not found at {coverage_path}")
        print("Make sure to run 'swift test --enable-code-coverage' first")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in coverage data: {e}")
        sys.exit(1)

def analyze_segments(segments: List) -> Tuple[int, int, int, int]:
    """
    Analyze coverage segments in detail.
    Returns (covered_lines, total_lines, covered_branches, total_branches)
    """
    if not segments:
        return 0, 0, 0, 0
    
    lines = {}  # line_num -> is_covered
    branches = []
    
    for segment in segments:
        line = segment[0]
        col = segment[1]
        count = segment[2]
        is_region = segment[3]
        has_count = segment[4]
        
        if line not in lines:
            lines[line] = count > 0
        else:
            lines[line] = lines[line] or (count > 0)
        
        if is_region and has_count:
            branches.append(count > 0)
    
    covered_lines = sum(1 for covered in lines.values() if covered)
    total_lines = len(lines)
    covered_branches = sum(1 for covered in branches if covered)
    total_branches = len(branches)
    
    return covered_lines, total_lines, covered_branches, total_branches

def should_include_file(filename: str, filter_pattern: Optional[str]) -> bool:
    """Check if a file should be included based on the filter pattern."""
    if not filter_pattern:
        return True
    return filter_pattern in filename

def analyze_file_coverage(coverage_data: dict, package_name: str, filter_pattern: Optional[str] = None) -> Dict[str, Dict]:
    """
    Analyze coverage data and extract statistics for each file.
    Returns a dictionary mapping file paths to coverage statistics.
    """
    results = {}
    
    data = coverage_data.get('data', [])
    
    for file_entry in data:
        for file_data in file_entry.get('files', []):
            filename = file_data.get('filename', '')
            
            # Only analyze files from the target package
            if f'/Sources/{package_name}/' not in filename:
                continue
            
            # Apply filter if specified
            if not should_include_file(filename, filter_pattern):
                continue
            
            # Extract relative path and categorize
            parts = filename.split(f'/Sources/{package_name}/')
            if len(parts) == 2:
                relative_path = parts[1]
                path_parts = relative_path.split('/')
                
                # Determine category (folder structure)
                if len(path_parts) > 1:
                    category = path_parts[0]
                    file_name = Path(filename).stem
                else:
                    category = 'Root'
                    file_name = Path(filename).stem
                
                # Get segments
                segments = file_data.get('segments', [])
                
                # Analyze segments
                covered_lines, total_lines, covered_branches, total_branches = analyze_segments(segments)
                
                # Calculate percentages
                line_pct = (covered_lines / total_lines * 100) if total_lines > 0 else 100.0
                branch_pct = (covered_branches / total_branches * 100) if total_branches > 0 else 100.0
                
                # Overall coverage (weighted average)
                if total_lines > 0 and total_branches > 0:
                    overall_pct = (line_pct * 0.5 + branch_pct * 0.5)
                elif total_lines > 0:
                    overall_pct = line_pct
                elif total_branches > 0:
                    overall_pct = branch_pct
                else:
                    overall_pct = 100.0
                
                # Identify uncovered regions
                uncovered_regions = []
                for segment in segments:
                    line = segment[0]
                    col = segment[1]
                    count = segment[2]
                    is_region = segment[3]
                    has_count = segment[4]
                    
                    if is_region and has_count and count == 0:
                        uncovered_regions.append({
                            'line': line,
                            'column': col
                        })
                
                results[filename] = {
                    'category': category,
                    'name': file_name,
                    'relative_path': relative_path,
                    'line_coverage': {
                        'covered': covered_lines,
                        'total': total_lines,
                        'percentage': line_pct
                    },
                    'branch_coverage': {
                        'covered': covered_branches,
                        'total': total_branches,
                        'percentage': branch_pct
                    },
                    'overall_percentage': overall_pct,
                    'uncovered_regions': uncovered_regions
                }
    
    return results

def generate_report(coverage_stats: Dict[str, Dict], package_name: str, filter_pattern: Optional[str]) -> str:
    """Generate a formatted coverage report."""
    lines = []
    lines.append("=" * 100)
    lines.append(f"CODE COVERAGE ANALYSIS - {package_name}")
    if filter_pattern:
        lines.append(f"Filter: Files containing '{filter_pattern}'")
    lines.append("=" * 100)
    lines.append("")
    
    if not coverage_stats:
        lines.append("No files found matching the criteria.")
        lines.append("")
        lines.append("=" * 100)
        return "\n".join(lines)
    
    # Group by category
    by_category = defaultdict(list)
    for filepath, stats in coverage_stats.items():
        by_category[stats['category']].append((filepath, stats))
    
    # Calculate overall statistics
    total_lines_covered = 0
    total_lines = 0
    total_branches_covered = 0
    total_branches = 0
    
    for stats in coverage_stats.values():
        total_lines_covered += stats['line_coverage']['covered']
        total_lines += stats['line_coverage']['total']
        total_branches_covered += stats['branch_coverage']['covered']
        total_branches += stats['branch_coverage']['total']
    
    overall_line_pct = (total_lines_covered / total_lines * 100) if total_lines > 0 else 0.0
    overall_branch_pct = (total_branches_covered / total_branches * 100) if total_branches > 0 else 0.0
    overall_pct = (overall_line_pct * 0.5 + overall_branch_pct * 0.5) if total_lines > 0 and total_branches > 0 else 0.0
    
    # Overall Summary
    lines.append("OVERALL SUMMARY")
    lines.append("-" * 100)
    lines.append(f"Total Files Analyzed: {len(coverage_stats)}")
    lines.append(f"Overall Line Coverage: {total_lines_covered}/{total_lines} ({overall_line_pct:.1f}%)")
    lines.append(f"Overall Branch Coverage: {total_branches_covered}/{total_branches} ({overall_branch_pct:.1f}%)")
    lines.append(f"Combined Coverage Score: {overall_pct:.1f}%")
    lines.append("")
    
    # Identify areas needing attention
    needs_attention = []
    for filepath, stats in coverage_stats.items():
        if stats['overall_percentage'] < 100.0:
            needs_attention.append((stats['category'], stats['name'], stats['overall_percentage'], len(stats['uncovered_regions'])))
    
    if needs_attention:
        lines.append("âš ï¸  FILES WITH COVERAGE GAPS:")
        lines.append("-" * 100)
        for category, name, pct, uncovered_count in sorted(needs_attention, key=lambda x: x[2]):
            lines.append(f"  {category}/{name}: {pct:.1f}% coverage ({uncovered_count} uncovered regions)")
        lines.append("")
    
    # Category-by-category breakdown
    for category in sorted(by_category.keys()):
        lines.append("")
        lines.append("=" * 100)
        lines.append(f"CATEGORY: {category}")
        lines.append("=" * 100)
        lines.append("")
        
        files = sorted(by_category[category], key=lambda x: x[1]['name'])
        
        category_lines_covered = 0
        category_lines_total = 0
        category_branches_covered = 0
        category_branches_total = 0
        
        for filepath, stats in files:
            category_lines_covered += stats['line_coverage']['covered']
            category_lines_total += stats['line_coverage']['total']
            category_branches_covered += stats['branch_coverage']['covered']
            category_branches_total += stats['branch_coverage']['total']
            
            name = stats['name']
            line_cov = stats['line_coverage']
            branch_cov = stats['branch_coverage']
            
            status = "âœ…" if stats['overall_percentage'] == 100.0 else "âš ï¸ "
            
            lines.append(f"{status} {name}")
            lines.append(f"   Path: {stats['relative_path']}")
            lines.append(f"   Line Coverage:   {line_cov['covered']}/{line_cov['total']} ({line_cov['percentage']:.1f}%)")
            lines.append(f"   Branch Coverage: {branch_cov['covered']}/{branch_cov['total']} ({branch_cov['percentage']:.1f}%)")
            lines.append(f"   Overall Score:   {stats['overall_percentage']:.1f}%")
            
            if stats['uncovered_regions']:
                lines.append(f"   Uncovered Regions: {len(stats['uncovered_regions'])}")
                for region in stats['uncovered_regions'][:5]:
                    lines.append(f"      Line {region['line']}, Col {region['column']}")
                if len(stats['uncovered_regions']) > 5:
                    lines.append(f"      ... and {len(stats['uncovered_regions']) - 5} more")
            
            lines.append("")
        
        # Category summary
        cat_line_pct = (category_lines_covered / category_lines_total * 100) if category_lines_total > 0 else 0.0
        cat_branch_pct = (category_branches_covered / category_branches_total * 100) if category_branches_total > 0 else 0.0
        cat_overall = (cat_line_pct * 0.5 + cat_branch_pct * 0.5) if category_lines_total > 0 and category_branches_total > 0 else 0.0
        
        lines.append(f"Category Summary: {cat_overall:.1f}% overall coverage")
        lines.append(f"  Lines: {category_lines_covered}/{category_lines_total} ({cat_line_pct:.1f}%)")
        lines.append(f"  Branches: {category_branches_covered}/{category_branches_total} ({cat_branch_pct:.1f}%)")
    
    # Summary by coverage level
    lines.append("")
    lines.append("")
    lines.append("=" * 100)
    lines.append("COVERAGE QUALITY DISTRIBUTION")
    lines.append("=" * 100)
    lines.append("")
    
    perfect = []    # 100%
    excellent = []  # 95-99.9%
    good = []       # 85-95%
    fair = []       # 70-85%
    poor = []       # <70%
    
    for filepath, stats in coverage_stats.items():
        pct = stats['overall_percentage']
        name = f"{stats['category']}/{stats['name']}"
        entry = (name, pct, stats['line_coverage'], stats['branch_coverage'])
        
        if pct == 100.0:
            perfect.append(entry)
        elif pct >= 95:
            excellent.append(entry)
        elif pct >= 85:
            good.append(entry)
        elif pct >= 70:
            fair.append(entry)
        else:
            poor.append(entry)
    
    lines.append(f"ðŸŽ¯ Perfect Coverage (100%): {len(perfect)} files")
    if len(perfect) <= 10:
        for name, pct, line_cov, branch_cov in sorted(perfect):
            lines.append(f"   âœ… {name}")
    else:
        lines.append(f"   (All {len(perfect)} files have perfect coverage!)")
    
    lines.append("")
    lines.append(f"âœ… Excellent Coverage (95-99%): {len(excellent)} files")
    for name, pct, line_cov, branch_cov in sorted(excellent, key=lambda x: x[1], reverse=True):
        lines.append(f"   {name}: {pct:.1f}% (L:{line_cov['percentage']:.1f}%, B:{branch_cov['percentage']:.1f}%)")
    
    if good:
        lines.append("")
        lines.append(f"ðŸ‘ Good Coverage (85-95%): {len(good)} files")
        for name, pct, line_cov, branch_cov in sorted(good, key=lambda x: x[1], reverse=True):
            lines.append(f"   {name}: {pct:.1f}% (L:{line_cov['percentage']:.1f}%, B:{branch_cov['percentage']:.1f}%)")
    
    if fair:
        lines.append("")
        lines.append(f"âš ï¸  Fair Coverage (70-85%): {len(fair)} files")
        for name, pct, line_cov, branch_cov in sorted(fair, key=lambda x: x[1], reverse=True):
            lines.append(f"   {name}: {pct:.1f}% (L:{line_cov['percentage']:.1f}%, B:{branch_cov['percentage']:.1f}%)")
    
    if poor:
        lines.append("")
        lines.append(f"ðŸ”´ Poor Coverage (<70%): {len(poor)} files")
        for name, pct, line_cov, branch_cov in sorted(poor, key=lambda x: x[1], reverse=True):
            lines.append(f"   {name}: {pct:.1f}% (L:{line_cov['percentage']:.1f}%, B:{branch_cov['percentage']:.1f}%)")
    
    lines.append("")
    lines.append("=" * 100)
    
    return "\n".join(lines)

def find_coverage_file(package_path: Path) -> Optional[Path]:
    """Find the coverage JSON file for a package."""
    # Try common build locations
    build_dirs = [
        package_path / '.build' / 'arm64-apple-macosx' / 'debug' / 'codecov',
        package_path / '.build' / 'x86_64-apple-macosx' / 'debug' / 'codecov',
        package_path / '.build' / 'debug' / 'codecov',
    ]
    
    package_name = package_path.name
    
    for build_dir in build_dirs:
        if build_dir.exists():
            # Look for the package's coverage file
            coverage_file = build_dir / f'{package_name}.json'
            if coverage_file.exists():
                return coverage_file
            
            # Fallback: look for any .json file
            json_files = list(build_dir.glob('*.json'))
            if json_files:
                return json_files[0]
    
    return None

def main():
    parser = argparse.ArgumentParser(
        description='Analyze Swift code coverage data',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument('package_path', help='Path to the Swift package directory')
    parser.add_argument('--filter', help='Only analyze files matching this pattern')
    parser.add_argument('--output', help='Output file path (default: COVERAGE_REPORT.md in package dir)')
    
    args = parser.parse_args()
    
    # Resolve package path
    package_path = Path(args.package_path).resolve()
    if not package_path.exists():
        print(f"Error: Package path does not exist: {package_path}")
        sys.exit(1)
    
    package_name = package_path.name
    
    # Find coverage file
    print(f"Looking for coverage data for {package_name}...")
    coverage_file = find_coverage_file(package_path)
    
    if not coverage_file:
        print(f"\nError: Coverage data not found for {package_name}")
        print(f"Expected location: {package_path}/.build/.../codecov/{package_name}.json")
        print("\nPlease run tests with coverage enabled first:")
        print(f"  cd {package_path}")
        print(f"  swift test --enable-code-coverage")
        sys.exit(1)
    
    print(f"Found coverage data: {coverage_file}")
    
    print("Loading coverage data...")
    coverage_data = load_coverage_data(str(coverage_file))
    
    print(f"Analyzing coverage for {package_name}...")
    if args.filter:
        print(f"Filtering files containing: '{args.filter}'")
    
    coverage_stats = analyze_file_coverage(coverage_data, package_name, args.filter)
    
    print(f"Found {len(coverage_stats)} files\n")
    
    report = generate_report(coverage_stats, package_name, args.filter)
    print(report)
    
    # Save to file
    if args.output:
        output_path = Path(args.output)
    else:
        output_path = package_path / 'COVERAGE_REPORT.md'
    
    with open(output_path, 'w') as f:
        f.write(report)
    
    print(f"\nDetailed report saved to: {output_path}")

if __name__ == '__main__':
    main()
